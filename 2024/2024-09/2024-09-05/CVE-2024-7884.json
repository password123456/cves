{
  "dataType": "CVE_RECORD",
  "dataVersion": "5.1",
  "cveMetadata": {
    "cveId": "CVE-2024-7884",
    "assignerOrgId": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
    "state": "PUBLISHED",
    "assignerShortName": "Dfinity",
    "dateReserved": "2024-08-16T15:30:36.784Z",
    "datePublished": "2024-09-05T13:01:20.585Z",
    "dateUpdated": "2024-09-05T13:01:20.585Z"
  },
  "containers": {
    "cna": {
      "affected": [
        {
          "collectionURL": "https://crates.io/crates/ic-cdk",
          "defaultStatus": "unaffected",
          "packageName": "ic-cdk",
          "product": "ic-cdk",
          "repo": "https://github.com/dfinity/cdk-rs",
          "vendor": "Internet Computer",
          "versions": [
            {
              "changes": [
                {
                  "at": "0.8.2",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.8.2",
              "status": "affected",
              "version": "0.8.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.9.3",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.9.3",
              "status": "affected",
              "version": "0.9.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.10.1",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.10.1",
              "status": "affected",
              "version": "0.10.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.11.6",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.11.5",
              "status": "affected",
              "version": "0.11.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.12.2",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.12.2",
              "status": "affected",
              "version": "0.12.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.13.5",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.13.4",
              "status": "affected",
              "version": "0.13.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.14.1",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.14.1",
              "status": "affected",
              "version": "0.14.0",
              "versionType": "semver"
            },
            {
              "changes": [
                {
                  "at": "0.15.1",
                  "status": "unaffected"
                }
              ],
              "lessThan": "0.15.1",
              "status": "affected",
              "version": "0.15.0",
              "versionType": "semver"
            }
          ]
        }
      ],
      "descriptions": [
        {
          "lang": "en",
          "supportingMedia": [
            {
              "base64": false,
              "type": "text/html",
              "value": "When a canister method is called via <tt>ic_cdk::call*</tt> , a new Future <tt>CallFuture&nbsp;</tt>is created  and can be awaited by the caller to get the execution result. Internally, the state of the Future is tracked and stored in a struct called <tt>CallFutureState</tt>.  A bug in the polling implementation of the <tt>CallFuture</tt> allows multiple references to be held for this internal state and not all references were dropped before the <tt>Future</tt>&nbsp;is resolved. Since we have unaccounted references held, a copy of the internal state ended up being persisted in the canister's heap and thus causing a memory leak. <br><h3>Impact&nbsp;</h3>Canisters built in Rust with <tt>ic_cdk</tt>&nbsp;and <tt>ic_cdk_timers</tt>&nbsp;are affected. If these canisters call a canister method, use timers or heartbeat, they will likely leak a small amount of memory on every such operation. <b>In the worst case, this could lead to heap memory exhaustion triggered by an attacker. </b>Motoko based canisters are not affected by the bug.<br><h3>Patches</h3>The patch has been backported to all minor versions between <tt>&gt;= 0.8.0, &lt;= 0.15.0</tt>. The patched versions available are <tt>0.8.2, 0.9.3, 0.10.1, 0.11.6, 0.12.2, 0.13.5, 0.14.1, 0.15.1 </tt>and their previous versions have been yanked. <h3>Workarounds</h3>There are no known workarounds at the moment. Developers are recommended to upgrade their canister as soon as possible to the latest available patched version of <tt>ic_cdk</tt>&nbsp;to avoid running out of Wasm heap memory. <br><blockquote>Upgrading the canisters (without updating `ic_cdk`) also frees the leaked memory but it's only a temporary solution.</blockquote>"
            }
          ],
          "value": "When a canister method is called via ic_cdk::call* , a new Future CallFuture is created  and can be awaited by the caller to get the execution result. Internally, the state of the Future is tracked and stored in a struct called CallFutureState.  A bug in the polling implementation of the CallFuture allows multiple references to be held for this internal state and not all references were dropped before the Future is resolved. Since we have unaccounted references held, a copy of the internal state ended up being persisted in the canister's heap and thus causing a memory leak. \nImpact Canisters built in Rust with ic_cdk and ic_cdk_timers are affected. If these canisters call a canister method, use timers or heartbeat, they will likely leak a small amount of memory on every such operation. In the worst case, this could lead to heap memory exhaustion triggered by an attacker. Motoko based canisters are not affected by the bug.\nPatchesThe patch has been backported to all minor versions between >= 0.8.0, <= 0.15.0. The patched versions available are 0.8.2, 0.9.3, 0.10.1, 0.11.6, 0.12.2, 0.13.5, 0.14.1, 0.15.1 and their previous versions have been yanked. WorkaroundsThere are no known workarounds at the moment. Developers are recommended to upgrade their canister as soon as possible to the latest available patched version of ic_cdk to avoid running out of Wasm heap memory. \nUpgrading the canisters (without updating `ic_cdk`) also frees the leaked memory but it's only a temporary solution."
        }
      ],
      "impacts": [
        {
          "capecId": "CAPEC-131",
          "descriptions": [
            {
              "lang": "en",
              "value": "CAPEC-131 Resource Leak Exposure"
            }
          ]
        }
      ],
      "metrics": [
        {
          "cvssV3_1": {
            "attackComplexity": "LOW",
            "attackVector": "NETWORK",
            "availabilityImpact": "HIGH",
            "baseScore": 7.5,
            "baseSeverity": "HIGH",
            "confidentialityImpact": "NONE",
            "integrityImpact": "NONE",
            "privilegesRequired": "NONE",
            "scope": "UNCHANGED",
            "userInteraction": "NONE",
            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "version": "3.1"
          },
          "format": "CVSS",
          "scenarios": [
            {
              "lang": "en",
              "value": "GENERAL"
            }
          ]
        }
      ],
      "problemTypes": [
        {
          "descriptions": [
            {
              "cweId": "CWE-401",
              "description": "CWE-401 Missing Release of Memory after Effective Lifetime",
              "lang": "en",
              "type": "CWE"
            }
          ]
        }
      ],
      "providerMetadata": {
        "orgId": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
        "shortName": "Dfinity",
        "dateUpdated": "2024-09-05T13:01:20.585Z"
      },
      "references": [
        {
          "url": "https://github.com/dfinity/cdk-rs/pull/509"
        },
        {
          "url": "https://docs.rs/ic-cdk/latest/ic_cdk/"
        },
        {
          "url": "https://internetcomputer.org/docs/current/references/ic-interface-spec"
        }
      ],
      "source": {
        "discovery": "UNKNOWN"
      },
      "title": "Memory leak when calling a canister method via `ic_cdk::call`",
      "x_generator": {
        "engine": "Vulnogram 0.2.0"
      }
    }
  }
}